//
// Created by Lddyss on 2025/2/1.
// generated by deepseek
//

#ifndef OVOSKIPLIST_RANDOM_H
#define OVOSKIPLIST_RANDOM_H

#include <random>
#include <atomic>
#include <array>
#include <thread>

class Random {
public:
    // 初始化（混合熵源 + 硬件种子）
    explicit Random(uint32_t seed = 0) {
        if (seed == 0) {
            seed = generate_strong_seed();
        }
        reseed(seed);
    }

    // 线程安全的核心生成函数（可指定范围）
    uint32_t operator()(uint32_t min = 0, uint32_t max = UINT32_MAX) {
        // 每个线程持有独立引擎副本避免锁竞争
        thread_local std::mt19937 local_engine = init_thread_local_engine();
        thread_local std::uniform_int_distribution<uint32_t> dist;

        if (min == 0 && max == UINT32_MAX) {
            return local_engine(); // 快速路径：直接输出32位
        } else {
            return dist(local_engine,
                        std::uniform_int_distribution<uint32_t>::param_type{min, max});
        }
    }

    // 批量生成（缓存友好）
    void fill_bulk(uint32_t* buffer, size_t count,
                   uint32_t min = 0, uint32_t max = UINT32_MAX) {
        thread_local std::mt19937 local_engine = init_thread_local_engine();
        std::generate_n(buffer, count, [&]() {
            return (*this)(min, max);
        });
    }

    // 原子性重播种（线程安全）
    void reseed(uint32_t seed) {
        master_seed_.store(seed, std::memory_order_relaxed);
        ++seed_version_;  // 使用序号标记种子版本
    }

private:
    // 混合熵源生成强种子
    static uint32_t generate_strong_seed() {
        std::random_device rd;
        std::array<uint32_t, 4> entropy = {
                rd(),
                static_cast<uint32_t>(std::chrono::high_resolution_clock::now()
                        .time_since_epoch().count()),
                static_cast<uint32_t>(reinterpret_cast<uintptr_t>(&entropy)),
                static_cast<uint32_t>(std::thread::hardware_concurrency())
        };
        std::seed_seq seq(entropy.begin(), entropy.end());
        uint32_t result;
        seq.generate(&result, &result + 1);
        return result;
    }

    // 线程本地引擎初始化（带版本控制）
    std::mt19937 init_thread_local_engine() {
        uint32_t seed = master_seed_.load(std::memory_order_relaxed);
        uint64_t version = seed_version_.load(std::memory_order_acquire);
        return std::mt19937(seed +
                            static_cast<uint32_t>(version) +
                            std::hash<std::thread::id>{}(std::this_thread::get_id()));
    }

    std::atomic<uint32_t> master_seed_;
    std::atomic<uint64_t> seed_version_{0};
};

#endif //OVOSKIPLIST_RANDOM_H
